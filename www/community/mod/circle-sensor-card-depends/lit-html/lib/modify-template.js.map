{"version":3,"file":"modify-template.js","sourceRoot":"","sources":["../src/lib/modify-template.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {Template, isTemplatePartActive, TemplatePart} from '/local/community/mod/circle-sensor-card-depends/lit-html/lit-html.js';\n\nconst walkerNodeFilter = NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |\nNodeFilter.SHOW_TEXT;\n\n/**\n * Removes the list of nodes from a Template safely. In addition to removing\n * nodes from the Template, the Template part indices are updated to match\n * the mutated Template DOM.\n *\n * As the template is walked the removal state is tracked and\n * part indices are adjusted as needed.\n *\n * div\n *   div#1 (remove) <-- start removing (removing node is div#1)\n *     div\n *       div#2 (remove)  <-- continue removing (removing node is still div#1)\n *         div\n * div <-- stop removing since previous sibling is the removing node (div#1, removed 4 nodes)\n */\nexport function removeNodesFromTemplate(template: Template, nodesToRemove: Set<Node>) {\n  const {element: {content}, parts} = template;\n  const walker = document.createTreeWalker(\n    content,\n    walkerNodeFilter,\n    null as any,\n    false);\n  let partIndex = 0;\n  let part = parts[0];\n  let nodeIndex = -1;\n  let removeCount = 0;\n  const nodesToRemoveInTemplate = [];\n  let currentRemovingNode: Node|null = null;\n  while (walker.nextNode()) {\n    nodeIndex++;\n    const node = walker.currentNode as Element;\n    // End removal if stepped past the removing node\n    if (node.previousSibling === currentRemovingNode) {\n      currentRemovingNode = null;\n    }\n    // A node to remove was found in the template\n    if (nodesToRemove.has(node)) {\n      nodesToRemoveInTemplate.push(node);\n      // Track node we're removing\n      if (currentRemovingNode === null) {\n        currentRemovingNode = node;\n      }\n    }\n    // When removing, increment count by which to adjust subsequent part indices\n    if (currentRemovingNode !== null) {\n      removeCount++;\n    }\n    while (part !== undefined && part.index === nodeIndex) {\n      // If part is in a removed node deactivate it by setting index to -1 or\n      // adjust the index as needed.\n      part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;\n      part = parts[++partIndex];\n    }\n  }\n  nodesToRemoveInTemplate.forEach((n) => n.parentNode!.removeChild(n));\n}\n\nconst countNodes = (node: Node) => {\n  let count = 1;\n  const walker = document.createTreeWalker(\n    node,\n    walkerNodeFilter,\n    null as any,\n    false);\n  while (walker.nextNode()) {\n    count++;\n  }\n  return count;\n};\n\nconst nextActiveIndexInTemplateParts = (parts: TemplatePart[], startIndex: number = -1) => {\n  for (let i = startIndex + 1; i < parts.length; i++) {\n    const part = parts[i];\n    if (isTemplatePartActive(part)) {\n      return i;\n    }\n  }\n  return -1;\n};\n\n/**\n * Inserts the given node into the Template, optionally before the given\n * refNode. In addition to inserting the node into the Template, the Template\n * part indices are updated to match the mutated Template DOM.\n */\nexport function insertNodeIntoTemplate(\n    template: Template, node: Node, refNode: Node|null = null) {\n  const {element: {content}, parts} = template;\n  // If there's no refNode, then put node at end of template.\n  // No part indices need to be shifted in this case.\n  if (refNode === null || refNode === undefined) {\n    content.appendChild(node);\n    return;\n  }\n  const walker = document.createTreeWalker(\n      content,\n      walkerNodeFilter,\n      null as any,\n      false);\n  let partIndex = nextActiveIndexInTemplateParts(parts);\n  let insertCount = 0;\n  let walkerIndex = -1;\n  while (walker.nextNode()) {\n    walkerIndex++;\n    const walkerNode = walker.currentNode as Element;\n    if (walkerNode === refNode) {\n      refNode.parentNode!.insertBefore(node, refNode);\n      insertCount = countNodes(node);\n    }\n    while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {\n      // If we've inserted the node, simply adjust all subsequent parts\n      if (insertCount > 0) {\n        while (partIndex !== -1) {\n          parts[partIndex].index += insertCount;\n          partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n        }\n        return;\n      }\n      partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n    }\n  }\n}\n"]}